<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="images/icon.png" type="image/png" sizes="168x168">
  <title>Consultium App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Loading overlay */
    #loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.8);
      display: none; /* start hidden */
      align-items: center;
      justify-content: center;
      z-index: 50;
    }
    /* Tailwind-spinner */
    .spinner {
      border: 4px solid #3b82f6; /* blauw */
      border-top-color: transparent;
      border-radius: 9999px; /* rond */
      width: 3rem;
      height: 3rem;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    body { font-family: 'Inter', sans-serif; background: #f8fafc; }
    .expanding-textarea {
      min-height: 80px;
      max-height: 640px;
      overflow-y: auto;
      resize: none;
      padding: 1rem 1rem 4rem;
    }
    .formatted-output { background: transparent; border: none; box-shadow: none; padding: 0; }
    .scrollable-box   { max-height: 240px; overflow-y: auto; background: transparent; padding: 0; }
    .fade-in { opacity: 0; animation: fadeIn 0.5s ease-out forwards; }
    @keyframes fadeIn { to { opacity: 1; } }
    .formatted-output ul { display: block; margin: 0 0 0.75rem 1.5rem; padding: 0; }
    .formatted-output li { display: list-item; margin-bottom: 0.5rem; }
    .formatted-output ul ul { margin-bottom: 0.5rem; margin-left: 1rem; }

    /* Knopstijl voor Live Whisper */
    .btn-live {
      @apply mt-4 ml-4 px-4 py-2 bg-green-100 text-green-700 rounded-full shadow hover:bg-green-200 transition inline-flex items-center;
    }
    .btn-live.recording {
      @apply bg-red-100 text-red-700 hover:bg-red-200;
    }
  </style>
</head>
<body class="h-screen flex flex-col">
  <!-- Global loading overlay -->
  <div id="loading-overlay" class="flex"><div class="spinner"></div></div>

  <!-- Header -->
  <header class="flex items-center justify-between px-6 py-4 bg-white shadow">
    <div class="flex items-center space-x-3">
      <img src="static/images/logo.png" alt="Mediflow Logo"
           class="h-8 w-auto object-contain transform scale-[4] origin-left mt-0.5">
    </div>
    <div class="relative">
      <img src="static/images/default.png" alt="Profiel"
           class="w-10 h-10 rounded-full border border-gray-300 cursor-pointer"
           onclick="toggleMenu()">
      <div id="dropdown-menu" class="hidden absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg z-50">
        <a href="/account" class="block px-4 py-2 text-gray-700 hover:bg-gray-100">Account Instellingen</a>
        <a href="index.html" class="block px-4 py-2 text-gray-700 hover:bg-gray-100">Uitloggen</a>
      </div>
    </div>
    <script>
      function toggleMenu() {
        document.getElementById('dropdown-menu').classList.toggle('hidden');
      }
      window.addEventListener('click', function(e) {
        if (!e.target.closest('img') && !e.target.closest('#dropdown-menu')) {
          document.getElementById('dropdown-menu').classList.add('hidden');
        }
      });
    </script>
  </header>

  <!-- üîä Recording overlay (ongewijzigd) -->
  <div id="recording-overlay"
       class="fixed inset-0 flex flex-col items-center justify-center bg-white/80 backdrop-blur-sm hidden z-50">
    <!-- ‚ùå Cancel knop -->
    <button id="cancel-recording-btn"
            class="absolute top-6 right-6 text-3xl text-gray-500 hover:text-gray-700">&times;</button>
    <canvas id="waveform-canvas" class="w-full max-w-4xl h-40"></canvas>
    <button id="soep-recording-btn"
            class="mt-8 px-10 py-4 bg-blue-600 text-white text-2xl font-bold rounded-full shadow-lg hover:bg-blue-700 transition">
      SOEP
    </button>
  </div>

  <main class="flex-1 px-8 py-10 flex flex-col items-center">
    <!-- Input Box -->
    <div class="mt-8 bg-white p-6 rounded-3xl shadow-sm border border-gray-200 w-2/3 mx-auto">
      <div class="relative">
        <textarea id="text-input"
                  placeholder="Hier typen of live transcriptie‚Ä¶"
                  class="w-full p-4 text-lg placeholder-gray-400 bg-transparent outline-none expanding-textarea"
                  readonly></textarea>
      </div>
      <!-- Bestaande "Start Opname" knop -->
      <button id="whisper-btn"
              class="mt-4 px-4 py-2 bg-blue-100 text-blue-700 rounded-full shadow hover:bg-blue-200 transition inline-flex items-center">
        üéôÔ∏è Start Opname
      </button>
      <!-- Nieuwe "Live Whisper" knop -->
      <button id="live-whisper-btn" class="btn-live">
        üéôÔ∏è Live Whisper
      </button>
    </div>

    <!-- Format Buttons -->
    <div class="mt-4 flex justify-center">
      <button id="generate-soep"
              class="px-8 py-3 bg-gray-200 text-gray-700 rounded-full shadow hover:bg-gray-300 font-medium">
        SOEP
      </button>
    </div>

    <!-- SOEP Verslag Container (ongewijzigd) -->
    <div id="verslag-container" class="mt-8 w-2/3 space-y-6 hidden">
      <template id="section-template">
        <div class="bg-white p-6 rounded-3xl shadow-sm border border-gray-200 fade-in">
          <h3 class="text-xl font-semibold mb-4">LETTER</h3>
          <div class="relative">
            <div class="scrollable-box">
              <div class="formatted-output text-lg leading-relaxed"></div>
            </div>
            <button class="absolute bottom-4 right-4 px-2 py-1 bg-gray-100 text-gray-700 rounded-full shadow">
              üìã
            </button>
          </div>
        </div>
      </template>
      <div id="s-box"></div>
      <div id="o-box"></div>
      <div id="e-box"></div>
      <div id="p-box"></div>
    </div>
  </main>

  <!-- ‚ú® UTILITIES (ongewijzigd) -->
  <script>
    // Bullet formatter
    function formatBullets(text) {
      const parts = text.split('‚Ä¢').slice(1);
      let html = '<ul class="list-disc pl-6 mb-4">';
      parts.forEach(p => {
        const item = p.trim();
        if (item) html += `<li class="mb-2">${item}</li>`;
      });
      html += '</ul>';
      return html;
    }

    // Build SOEP section
    function createSection(letter, content) {
      const tmpl = document.getElementById('section-template');
      const clone = tmpl.content.cloneNode(true);
      clone.querySelector('h3').textContent = letter;
      const outputDiv = clone.querySelector('.formatted-output');
      const outputId = `${letter.toLowerCase()}-output`;
      outputDiv.id = outputId;
      const normalized = content.replace(/-\s*/g, '‚Ä¢ ');
      outputDiv.innerHTML = formatBullets(normalized);
      clone.querySelector('button').setAttribute('onclick', `copyToClipboard('${outputId}')`);
      return clone;
    }

    // Copy helper
    function copyToClipboard(id) {
      const field = document.getElementById(id);
      if (!field) return console.error(`#${id} niet gevonden`);
      const text = field.innerText || field.textContent;
      navigator.clipboard.writeText(text).then(() => {
        const orig = field.style.backgroundColor;
        field.style.backgroundColor = '#d1fae5';
        setTimeout(() => field.style.backgroundColor = orig, 800);
      }).catch(err => console.error('Fout bij kopi√´ren:', err));
    }
  </script>

  <!-- üß† SOEP GENERATOR FUNCTION (ongewijzigd) -->
  <script>
    async function generateSOEP() {
      const promptText = document.getElementById('text-input').value.trim();
      if (!promptText) {
        alert('Transcriptie of tekst ontbreekt.');
        return;
      }
      const loader = document.getElementById('loading-overlay');
      const btn = document.getElementById('generate-soep');
      loader.style.display = 'flex';
      btn.disabled = true;
      try {
        const res = await fetch('https://f96d-2001-1c00-9901-3500-7829-6a97-7f65-524e.ngrok-free.app/generate-soep', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: promptText })
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        ['S', 'O', 'E', 'P'].forEach(letter => {
          const box = document.getElementById(`${letter.toLowerCase()}-box`);
          box.innerHTML = '';
          box.appendChild(createSection(letter, data[letter.toLowerCase()]));
        });
        document.getElementById('verslag-container').classList.remove('hidden');
        document.getElementById('verslag-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (err) {
        console.error(err);
        alert('Serverfout bij SOEP-generatie.');
      } finally {
        loader.style.display = 'none';
        btn.disabled = false;
      }
    }
    document.getElementById('generate-soep').addEventListener('click', generateSOEP);
  </script>

  <!-- üì¢ AUDIO RECORDING + WAVEFORM (ongewijzigd) -->
  <script>
    let whisperRecorder = null;
    let whisperStream = null;
    let whisperChunks = [];
    let audioCtx = null; // Web-Audio context
    let analyser = null;
    let animationFrameId = null;
    let isCancelled = false;

    const startBtn = document.getElementById('whisper-btn');
    const overlay = document.getElementById('recording-overlay');
    const soepRecBtn = document.getElementById('soep-recording-btn');
    const cancelBtn = document.getElementById('cancel-recording-btn');

    startBtn.addEventListener('click', startRecording);
    soepRecBtn.addEventListener('click', stopAndGenerate);
    cancelBtn.addEventListener('click', cancelRecording);

    async function startRecording() {
      try {
        isCancelled = false;
        whisperStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        whisperChunks = [];
        const options = MediaRecorder.isTypeSupported('audio/webm')
          ? { mimeType: 'audio/webm' }
          : { mimeType: 'audio/webm;codecs=opus' };
        whisperRecorder = new MediaRecorder(whisperStream, options);
        whisperRecorder.ondataavailable = e => {
          if (e.data.size > 0) whisperChunks.push(e.data);
        };
        whisperRecorder.onstop = handleStop;
        whisperRecorder.start();

        overlay.classList.remove('hidden');
        startBtn.disabled = true;
        initWaveform(whisperStream);
      } catch (err) {
        console.error('üé§ Microfoonfout:', err);
        alert('‚ùå Kon microfoon niet starten.');
      }
    }

    function cancelRecording() {
      if (whisperRecorder && whisperRecorder.state === 'recording') {
        isCancelled = true;
        whisperRecorder.stop();
      }
      overlay.classList.add('hidden');
      startBtn.disabled = false;
      cancelWaveform();
      if (whisperStream) whisperStream.getTracks().forEach(t => t.stop());
      whisperChunks = []; // gooi alles weg
    }

    function stopAndGenerate() {
      if (whisperRecorder && whisperRecorder.state === 'recording') whisperRecorder.stop();
      cancelWaveform();
      overlay.classList.add('hidden');
      startBtn.disabled = false;
    }

    async function handleStop() {
      if (isCancelled) {
        isCancelled = false;
        return;
      }
      const audioBlob = new Blob(whisperChunks, { type: 'audio/webm' });
      const formData = new FormData();
      formData.append('file', audioBlob, 'recording.webm');
      const loader = document.getElementById('loading-overlay');
      loader.style.display = 'flex';
      try {
        const response = await fetch('https://f96d-2001-1c00-9901-3500-7829-6a97-7f65-524e.ngrok-free.app/transcribe-audio', {
          method: 'POST',
          body: formData
        });
        const result = await response.json();
        if (result.error) {
          alert('‚ùå Fout bij transcriptie: ' + result.error);
          return;
        }
        document.getElementById('text-input').value = result.transcription;
        await generateSOEP();
      } catch (err) {
        console.error('‚ùå Fout bij uploaden of SOEP:', err);
        alert('Er ging iets mis tijdens transcriptie of SOEP-generatie.');
      } finally {
        loader.style.display = 'none';
        if (whisperStream) whisperStream.getTracks().forEach(t => t.stop());
      }
    }

    /* Waveform */
    const NUM_BARS = 40, COLOR = '#2e5884';
    let smoothData = new Float32Array(NUM_BARS);

    function initWaveform(stream) {
      const canvas = document.getElementById('waveform-canvas');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = canvas.clientHeight * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.strokeStyle = COLOR;
      ctx.lineCap = 'round';
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      const source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyser);
      const raw = new Uint8Array(analyser.frequencyBinCount);
      const draw = () => {
        animationFrameId = requestAnimationFrame(draw);
        analyser.getByteTimeDomainData(raw);
        const step = Math.floor(raw.length / NUM_BARS);
        for (let i = 0; i < NUM_BARS; i++) {
          const target = (raw[i * step] / 255) * canvas.height * 0.4;
          smoothData[i] = smoothData[i] * 0.8 + target * 0.2;
        }
        ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        const barSpace = (canvas.width / dpr) / NUM_BARS;
        const mid = (canvas.height / dpr) / 2;
        ctx.lineWidth = barSpace * 0.6;
        for (let i = 0; i < NUM_BARS; i++) {
          const h = smoothData[i];
          const x = i * barSpace + barSpace / 2;
          ctx.beginPath();
          ctx.moveTo(x, mid - h / 2);
          ctx.lineTo(x, mid + h / 2);
          ctx.stroke();
        }
      };
      draw();
    }

    function cancelWaveform() {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      if (audioCtx) audioCtx.close();
      const canvas = document.getElementById('waveform-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  </script>

  <!-- üìù Auto-expanding textareas (ongewijzigd) -->
  <script>
    document.querySelectorAll('.expanding-textarea').forEach(t => {
      const max = 640;
      const adjust = () => {
        t.style.height = 'auto';
        const h = Math.min(t.scrollHeight, max);
        t.style.height = h + 'px';
        t.style.overflowY = t.scrollHeight > max ? 'auto' : 'hidden';
      };
      t.addEventListener('input', adjust);
      t.addEventListener('paste', () => setTimeout(adjust, 0));
      adjust();
    });
  </script>

  <!-- üó£Ô∏è LIVE WHISPER -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <script>
    // Initialize Socket.IO connection with proper configuration
    const BACKEND_WS_URL = window.location.protocol === 'https:' 
        ? 'wss://' + window.location.host
        : 'ws://' + window.location.host;
        
    const socket = io(BACKEND_WS_URL, {
        transports: ['websocket'],
        path: '/socket.io/',
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
        timeout: 20000
    });

    const liveBtn = document.getElementById('live-whisper-btn');
    const transcriptArea = document.getElementById('text-input');
    let mediaRecorderLive = null;
    let isRecording = false;
    let audioContext = null;
    let audioWorkletNode = null;

    // Socket.IO event handlers with improved error handling
    socket.on('connect', () => {
        console.log('Connected to WebSocket server');
        liveBtn.disabled = false;
    });

    socket.on('connect_error', (error) => {
        console.error('WebSocket connection error:', error);
        liveBtn.disabled = true;
        stopRecording();
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from WebSocket server');
        liveBtn.disabled = true;
        stopRecording();
    });

    socket.on('transcription_result', (data) => {
        const text = data.text || '';
        if (text.trim()) {
            transcriptArea.value += text + ' ';
            transcriptArea.scrollTop = transcriptArea.scrollHeight;
        }
    });

    socket.on('error', (data) => {
        console.error('Server error:', data);
        alert('Error during transcription: ' + data.message);
    });

    // AudioWorklet for precise chunk size control
    const workletCode = `
        class AudioChunkProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this._bufferSize = 4096;  // Must be multiple of 4
                this._buffer = new Float32Array(this._bufferSize);
                this._bytesWritten = 0;
            }
            
            process(inputs, outputs, parameters) {
                const input = inputs[0][0];
                if (!input) return true;
                
                // Ensure we only write complete chunks
                const samplesToWrite = Math.min(
                    input.length,
                    this._bufferSize - this._bytesWritten
                );
                
                for (let i = 0; i < samplesToWrite; i++) {
                    this._buffer[this._bytesWritten] = input[i];
                    this._bytesWritten++;
                }
                
                if (this._bytesWritten >= this._bufferSize) {
                    this.port.postMessage({
                        audioData: this._buffer.slice(0, this._bufferSize)
                    });
                    this._bytesWritten = 0;
                }
                
                return true;
            }
        }
        registerProcessor('audio-chunk-processor', AudioChunkProcessor);
    `;

    // Helper function to ensure audio data length is multiple of 4
    function padAudioData(audioData) {
        const remainder = audioData.length % 4;
        if (remainder === 0) return audioData;
        
        const paddedLength = audioData.length + (4 - remainder);
        const paddedData = new Float32Array(paddedLength);
        paddedData.set(audioData);
        // Fill remaining samples with silence
        for (let i = audioData.length; i < paddedLength; i++) {
            paddedData[i] = 0;
        }
        return paddedData;
    }

    // Helper function to stop recording with proper cleanup
    async function stopRecording() {
        if (audioWorkletNode) {
            audioWorkletNode.disconnect();
            audioWorkletNode = null;
        }
        if (audioContext) {
            await audioContext.close();
            audioContext = null;
        }
        if (isRecording) {
            socket.emit('stop_transcription');
        }
        liveBtn.textContent = 'üéôÔ∏è Live Whisper';
        liveBtn.classList.remove('recording');
        isRecording = false;
    }

    // Live Whisper button handler with improved audio setup
    liveBtn.addEventListener('click', async () => {
        if (isRecording) {
            await stopRecording();
        } else {
            try {
                // Initialize audio context with proper settings
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,
                    channelCount: 1,
                    latencyHint: 'interactive'
                });

                // Load and register the AudioWorklet
                const workletBlob = new Blob([workletCode], { type: 'application/javascript' });
                const workletUrl = URL.createObjectURL(workletBlob);
                await audioContext.audioWorklet.addModule(workletUrl);
                URL.revokeObjectURL(workletUrl);

                // Get microphone access with optimal settings
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Set up audio processing pipeline
                const source = audioContext.createMediaStreamSource(stream);
                audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-chunk-processor');
                
                // Handle audio chunks from worklet
                audioWorkletNode.port.onmessage = (event) => {
                    if (isRecording && event.data.audioData) {
                        const paddedData = padAudioData(event.data.audioData);
                        socket.emit('audio_chunk', paddedData.buffer);
                    }
                };

                // Connect audio nodes
                source.connect(audioWorkletNode);
                audioWorkletNode.connect(audioContext.destination);

                // Start recording
                isRecording = true;
                socket.emit('start_transcription');
                liveBtn.textContent = 'üõë Stop Live Whisper';
                liveBtn.classList.add('recording');
                transcriptArea.value = '';

            } catch (err) {
                console.error('Error starting live transcription:', err);
                alert('Could not start microphone: ' + err.message);
                await stopRecording();
            }
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', stopRecording);
  </script>
</body>
</html>
